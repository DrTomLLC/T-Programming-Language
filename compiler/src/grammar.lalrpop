use std::str::FromStr;
use crate::ast::*;

grammar;

pub Program: Vec<Item> = {
    Item* => <>
};

pub Item: Item = {
    Function => Item::Function(<>),
    Struct => Item::Struct(<>),
    Import => Item::Import(<>),
};

pub Function<Identifier>: FunctionDecl = {
    "fn" <name:Identifier> "(" <params:CommaList<Parameter>> ")" <return_type:("->" <Type>)?> <body:Block> => {
        FunctionDecl {
            name,
            params,
            return_type,
            body,
        }
    }
};

pub Struct: StructDecl = {
    "struct" <name:Identifier> "{" <fields:CommaList<Field>> "}" => {
        StructDecl {
            name,
            fields,
        }
    }
};

pub Import: ImportDecl = {
    "import" <path:StringLiteral> ";" => ImportDecl { path },
};

pub Parameter: Parameter = {
    <name:Identifier> ":" <ty:Type> => Parameter { name, ty }
};

pub Field: Field = {
    <name:Identifier> ":" <ty:Type> => Field { name, ty }
};

pub Type: Type = {
    Identifier => Type::Named(<>),
    "i32" => Type::I32,
    "f64" => Type::F64,
    "bool" => Type::Bool,
    "string" => Type::String,
};

pub Block: Block = {
    "{" <stmts:Statement*> <expr:Expression?> "}" => Block { stmts, expr }
};

pub Statement: Statement = {
    <expr:Expression> ";" => Statement::Expression(expr),
    "let" <name:Identifier> "=" <expr:Expression> ";" => Statement::Let { name, expr },
    "return" <expr:Expression?> ";" => Statement::Return(expr),
};

pub Expression: Expression = {
    Assignment,
};

pub Assignment: Expression = {
    <lhs:Or> "=" <rhs:Assignment> => Expression::Assignment {
        lhs: Box::new(lhs),
        rhs: Box::new(rhs),
    },
    Or,
};

pub Or: Expression = {
    <lhs:And> "||" <rhs:Or> => Expression::BinaryOp {
        op: BinaryOperator::Or,
        lhs: Box::new(lhs),
        rhs: Box::new(rhs),
    },
    And,
};

pub And: Expression = {
    <lhs:Equality> "&&" <rhs:And> => Expression::BinaryOp {
        op: BinaryOperator::And,
        lhs: Box::new(lhs),
        rhs: Box::new(rhs),
    },
    Equality,
};

pub Equality: Expression = {
    <lhs:Comparison> "==" <rhs:Equality> => Expression::BinaryOp {
        op: BinaryOperator::Equal,
        lhs: Box::new(lhs),
        rhs: Box::new(rhs),
    },
    <lhs:Comparison> "!=" <rhs:Equality> => Expression::BinaryOp {
        op: BinaryOperator::NotEqual,
        lhs: Box::new(lhs),
        rhs: Box::new(rhs),
    },
    Comparison,
};

pub Comparison: Expression = {
    <lhs:Addition> "<" <rhs:Comparison> => Expression::BinaryOp {
        op: BinaryOperator::Less,
        lhs: Box::new(lhs),
        rhs: Box::new(rhs),
    },
    <lhs:Addition> ">" <rhs:Comparison> => Expression::BinaryOp {
        op: BinaryOperator::Greater,
        lhs: Box::new(lhs),
        rhs: Box::new(rhs),
    },
    Addition,
};

pub Addition: Expression = {
    <lhs:Multiplication> "+" <rhs:Addition> => Expression::BinaryOp {
        op: BinaryOperator::Add,
        lhs: Box::new(lhs),
        rhs: Box::new(rhs),
    },
    <lhs:Multiplication> "-" <rhs:Addition> => Expression::BinaryOp {
        op: BinaryOperator::Subtract,
        lhs: Box::new(lhs),
        rhs: Box::new(rhs),
    },
    Multiplication,
};

pub Multiplication: Expression = {
    <lhs:Unary> "*" <rhs:Multiplication> => Expression::BinaryOp {
        op: BinaryOperator::Multiply,
        lhs: Box::new(lhs),
        rhs: Box::new(rhs),
    },
    <lhs:Unary> "/" <rhs:Multiplication> => Expression::BinaryOp {
        op: BinaryOperator::Divide,
        lhs: Box::new(lhs),
        rhs: Box::new(rhs),
    },
    Unary,
};

pub Unary: Expression = {
    "!" <expr:Unary> => Expression::UnaryOp {
        op: UnaryOperator::Not,
        expr: Box::new(expr),
    },
    "-" <expr:Unary> => Expression::UnaryOp {
        op: UnaryOperator::Negate,
        expr: Box::new(expr),
    },
    Call,
};

pub Call: Expression = {
    <func:Primary> "(" <args:CommaList<Expression>> ")" => Expression::FunctionCall {
        func: Box::new(func),
        args,
    },
    Primary,
};

pub Primary: Expression = {
    IntegerLiteral => Expression::Integer(<>),
    FloatLiteral => Expression::Float(<>),
    StringLiteral => Expression::String(<>),
    BoolLiteral => Expression::Bool(<>),
    Identifier => Expression::Identifier(<>),
    "(" <Expression> ")",
};

CommaList<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

match {
    r"\s*" => { }, // Skip whitespace
    r"//[^\n\r]*[\n\r]*" => { }, // Skip line comments
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { }, // Skip block comments
    
    // Keywords
    "fn",
    "struct", 
    "import",
    "let",
    "return",
    "if",
    "else",
    "while",
    "for",
    "break",
    "continue",
    "true",
    "false",
    
    // Types
    "i32",
    "f64", 
    "bool",
    "string",
    
    // Operators and punctuation
    "==",
    "!=", 
    "<=",
    ">=",
    "&&",
    "||",
    "->",
    "=",
    "+",
    "-", 
    "*",
    "/",
    "<",
    ">",
    "!",
    "(",
    ")",
    "{",
    "}",
    "[",
    "]",
    ",",
    ";",
    ":",
    
    // Literals
    r"[0-9]+" => IntegerLiteral,
    r"[0-9]+\.[0-9]+" => FloatLiteral,
    r#""([^"\\]|\\.)*""# => StringLiteral,
    r"true|false" => BoolLiteral,
    r"[a-zA-Z_][a-zA-Z0-9_]*" => Identifier,
}